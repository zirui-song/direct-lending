b_con <- lsqlincon(C, d, A = G, b = g, Aeq = Fmatrix, beq = fmatrix)
b_con <- matrix(b_con, nrow = 20, ncol = 1)
e_con <- c(Y - W %*% b_con)
Q_unc <- sqrt(n)*norm(d - C %*% b_unc, type = "F")
Q_con <- sqrt(n)*norm(d - C %*% b_con, type = "F")
Q_diff <- Q_con - Q_unc
boot_res_con <- foreach(s=1:Nboot, .combine = c) %dopar% boot_fun(b_hat = b_con,
e_hat = e_con,
seed = s, r = r,
G = G, g = g,
Fmatrix = Fmatrix,
fmatrix = fmatrix)
boot_diff <- boot_res_con - boot_res_unc
return(1-ecdf(boot_diff)(Q_diff))
}
# set p for the CI solver
p <- 10
CI_bounds <- data.frame(income_decile = c(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10),
lb = c(NA, 20),
ub = c(NA, 20))
for (j in c(1,2,3,4,5,6,7,8,9,11,12,13,14,15,17,19,20)) {
# Define function to check whether p-val == 0.05 for a given null-hypothesis of equality
check_p_val <- function(x) {
Fmatrix = rep(0, 2*p)
Fmatrix = matrix(Fmatrix, nrow = 1)
Fmatrix[j] = 1
fmatrix = as.numeric(x)
p <- get_p_val(G = G, g = g, Fmatrix = Fmatrix, fmatrix = fmatrix, r = r_boot)
return(p-0.05)
}
if (j <= p){
ll = 1e-10
uu = 5
} else{
ll = -10
uu = -1e-10
}
# Find lower end of CI, using bi-section method:
lb_CI <- uniroot(check_p_val, lower = ll, upper = b_con[j])$root
# Find upper end of CI, 0 if we cannot reject, else using bi-section method:
if (check_p_val(0) > 0) {ub_CI <- 0.0}
else {ub_CI <- uniroot(check_p_val, lower = b_con[j], upper = uu)$root}
CI_bounds[j, "lb"] <- lb_CI
CI_bounds[j, "ub"] <- ub_CI
}
CI_bounds <- CI_bounds %>%
mutate(across(everything(), ~ ifelse(. == 20, lag(.), .)))
alphas <- merge(alphas, CI_bounds[1:10,], by="income_decile", all.x = TRUE)
betas <- merge(betas, CI_bounds[11:20,], by="income_decile", all.x = TRUE)
ggplot(data = alphas, aes(x = income_decile)) +
geom_line(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_line(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_point(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_point(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_line(aes(y = ub), linetype = "dashed", color = "black", na.rm = TRUE) +  # Upper bound dashed line
geom_line(aes(y = lb), linetype = "dashed", color = "black", na.rm = TRUE) +  # Lower bound dashed line
labs(x = "Income Decile", y = "GMM", title = "Alphas") +  # Axis labels
scale_x_continuous(breaks = 1:10) +  # Set x-axis breaks to 1 through 10
scale_color_manual(values = c("Constrained" = "coral", "Unconstrained" = "deepskyblue2")) +  # Custom colors
theme_minimal() +
theme(legend.title = element_blank())
ggplot(data = betas, aes(x = income_decile)) +
geom_line(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_line(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_point(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_point(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_line(aes(y = ub), linetype = "dashed", color = "black", na.rm = TRUE) +  # Upper bound dashed line
geom_line(aes(y = lb), linetype = "dashed", color = "black", na.rm = TRUE) +  # Lower bound dashed line
labs(x = "Income Decile", y = "GMM", title = "Betas") +  # Axis labels
scale_x_continuous(breaks = 1:10) +  # Set x-axis breaks to 1 through 10
scale_color_manual(values = c("Constrained" = "coral", "Unconstrained" = "deepskyblue2")) +  # Custom colors
theme_minimal() +
theme(legend.title = element_blank())
CI_bounds <- CI_bounds %>%
mutate(across(everything(), ~ ifelse(. == 20, lag(.), .)))
alphas <- merge(alphas, CI_bounds[1:10,], by="income_decile", all.x = TRUE)
betas <- merge(betas, CI_bounds[11:20,], by="income_decile", all.x = TRUE)
ggplot(data = alphas, aes(x = income_decile)) +
geom_line(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_line(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_point(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_point(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_line(aes(y = ub), linetype = "dashed", color = "deepskyblue2", na.rm = TRUE) +  # Upper bound dashed line
geom_line(aes(y = lb), linetype = "dashed", color = "deepskyblue2", na.rm = TRUE) +  # Lower bound dashed line
labs(x = "Income Decile", y = "GMM", title = "Alphas") +  # Axis labels
scale_x_continuous(breaks = 1:10) +  # Set x-axis breaks to 1 through 10
scale_color_manual(values = c("Constrained" = "coral", "Unconstrained" = "deepskyblue2")) +  # Custom colors
theme_minimal() +
theme(legend.title = element_blank())
CI_bounds <- CI_bounds %>%
mutate(across(everything(), ~ ifelse(. == 20, lag(.), .)))
alphas <- merge(alphas, CI_bounds[1:10,], by="income_decile", all.x = TRUE)
betas <- merge(betas, CI_bounds[11:20,], by="income_decile", all.x = TRUE)
ggplot(data = alphas, aes(x = income_decile)) +
geom_line(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_line(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_point(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_point(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_line(aes(y = ub), linetype = "dashed", color = "black", na.rm = TRUE) +  # Upper bound dashed line
geom_line(aes(y = lb), linetype = "dashed", color = "black", na.rm = TRUE) +  # Lower bound dashed line
labs(x = "Income Decile", y = "GMM", title = "Alphas") +  # Axis labels
scale_x_continuous(breaks = 1:10) +  # Set x-axis breaks to 1 through 10
scale_color_manual(values = c("Constrained" = "coral", "Unconstrained" = "deepskyblue2")) +  # Custom colors
theme_minimal() +
theme(legend.title = element_blank())
ggplot(data = betas, aes(x = income_decile)) +
geom_line(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_line(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_point(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_point(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_line(aes(y = ub), linetype = "dashed", color = "black", na.rm = TRUE) +  # Upper bound dashed line
geom_line(aes(y = lb), linetype = "dashed", color = "black", na.rm = TRUE) +  # Lower bound dashed line
labs(x = "Income Decile", y = "GMM", title = "Betas") +  # Axis labels
scale_x_continuous(breaks = 1:10) +  # Set x-axis breaks to 1 through 10
scale_color_manual(values = c("Constrained" = "coral", "Unconstrained" = "deepskyblue2")) +  # Custom colors
theme_minimal() +
theme(legend.title = element_blank())
CI_bounds <- CI_bounds %>%
mutate(across(everything(), ~ ifelse(. == 20, lag(.), .)))
alphas <- merge(alphas, CI_bounds[1:10,], by="income_decile", all.x = TRUE)
betas <- merge(betas, CI_bounds[11:20,], by="income_decile", all.x = TRUE)
ggplot(data = alphas, aes(x = income_decile)) +
geom_line(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_line(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_point(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_point(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_line(aes(y = ub), linetype = "dashed", color = "deepskyblue2", na.rm = TRUE) +  # Upper bound dashed line
geom_line(aes(y = lb), linetype = "dashed", color = "deepskyblue2", na.rm = TRUE) +  # Lower bound dashed line
labs(x = "Income Decile", y = "GMM", title = "Alphas") +  # Axis labels
scale_x_continuous(breaks = 1:10) +  # Set x-axis breaks to 1 through 10
scale_color_manual(values = c("Constrained" = "coral", "Unconstrained" = "deepskyblue2")) +  # Custom colors
theme_minimal() +
theme(legend.title = element_blank())
CI_bounds <- CI_bounds %>%
mutate(across(everything(), ~ ifelse(. == 20, lag(.), .)))
alphas <- merge(alphas, CI_bounds[1:10,], by="income_decile", all.x = TRUE)
betas <- merge(betas, CI_bounds[11:20,], by="income_decile", all.x = TRUE)
ggplot(data = alphas, aes(x = income_decile)) +
geom_line(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_line(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_point(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_point(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_line(aes(y = ub), linetype = "dashed", color = "blue", na.rm = TRUE) +  # Upper bound dashed line
geom_line(aes(y = lb), linetype = "dashed", color = "blue", na.rm = TRUE) +  # Lower bound dashed line
labs(x = "Income Decile", y = "GMM", title = "Alphas") +  # Axis labels
scale_x_continuous(breaks = 1:10) +  # Set x-axis breaks to 1 through 10
scale_color_manual(values = c("Constrained" = "coral", "Unconstrained" = "deepskyblue2")) +  # Custom colors
theme_minimal() +
theme(legend.title = element_blank())
CI_bounds <- CI_bounds %>%
mutate(across(everything(), ~ ifelse(. == 20, lag(.), .)))
alphas <- merge(alphas, CI_bounds[1:10,], by="income_decile", all.x = TRUE)
betas <- merge(betas, CI_bounds[11:20,], by="income_decile", all.x = TRUE)
ggplot(data = alphas, aes(x = income_decile)) +
geom_line(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_line(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_point(aes(y = constrained, color = "Constrained"), na.rm = TRUE) +  # Constrained line
geom_point(aes(y = unconstrained, color = "Unconstrained"), na.rm = TRUE) +   # Unconstrained line
geom_line(aes(y = ub), linetype = "dashed", color = "blue", na.rm = TRUE) +  # Upper bound dashed line
geom_line(aes(y = lb), linetype = "dashed", color = "blue", na.rm = TRUE) +  # Lower bound dashed line
labs(x = "Income Decile", y = "GMM", title = "Alphas") +  # Axis labels
scale_x_continuous(breaks = 1:10) +  # Set x-axis breaks to 1 through 10
scale_color_manual(values = c("Constrained" = "coral", "Unconstrained" = "deepskyblue2")) +  # Custom colors
theme_minimal() +
theme(legend.title = element_blank())
library(data.table)
library(dplyr)
library(haven)
library(stringr)
library(mvtnorm)
library(tidyr)
library(readxl)
library(ggplot2)
library(fuzzyjoin)
library(stringdist)
library(zoo)
library(readxl)
options(scipen = 999)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(data.table)
library(dplyr)
library(haven)
library(stringr)
library(mvtnorm)
library(tidyr)
library(readxl)
library(ggplot2)
library(fuzzyjoin)
library(stringdist)
library(zoo)
library(readxl)
options(scipen = 999)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
# Define the base figure path
figure_path <- "/Users/zrsong/Dropbox (MIT)/Apps/Overleaf/Information Covenants of Direct Lending/Figures"
##################################################
# Section 0: Clean combined_loancontracts and df_merged_crsp
##################################################
#df_merged_crsp <- fread("../Data/LoansFull/df_merged_crsp.csv")
# check if accession if unique by accession and type_attachment
#df_merged_clean <- df_merged_crsp %>%
#  group_by(accession, type_filing, type_attachment) %>%
#  filter(n() == 1)
#combined_loancontracts <- fread("../Data/LoansFull/combined_loancontracts.csv")
# check if obs is unique by accession and type_attachment
#combined_loancontracts_clean <- combined_loancontracts %>%
#  group_by(accession, type_filing, type_attachment) %>%
#  filter(n() == 1)
#cleaned_loancontracts <- inner_join(combined_loancontracts_clean, df_merged_clean, by = c("accession", "type_filing", "type_attachment"))
# save as csv
#write.csv(cleaned_loancontracts, "../Data/LoansFull/cleaned_loancontracts.csv", row.names = FALSE)
### inner join agreements_mm with combined_loancontracts to get text so that I can use to extract deal information
#cleaned_loancontracts <- fread("../Data/LoansFull/cleaned_loancontracts.csv")
# check if contracts have amendments (include words such as 'amendment', 'amended', 'amends', 'restatement', 'restated', 'restates') in the first 1000 characters
#cleaned_loancontracts <- cleaned_loancontracts %>%
#  mutate(is_amendment = ifelse(str_detect(str_sub(text, 1, 1000), "amendment|amended|amends|restatement|restated|restates"), 1, 0))
#cleaned_loancontracts_mm <- cleaned_loancontracts %>%
#  inner_join(agreements_mm %>% select(accession, type_filing, type_attachment), by = c("accession", "type_filing", "type_attachment"))
# keep only non-amendment contracts
#cleaned_loancontracts_mm <- cleaned_loancontracts_mm %>%
#  filter(is_amendment == 0)
# save as csv
#write.csv(cleaned_loancontracts_mm, "../Data/LoansFull/combined_loancontracts_mm.csv", row.names = FALSE)
# read in cleaned_loancontracts_mm
cleaned_loancontracts_mm <- fread("../Data/LoansFull/combined_loancontracts_mm.csv")
# check for unique years and number of observations by year
# Count number of observations by year
cleaned_loancontracts_mm <- cleaned_loancontracts_mm %>%
group_by(year) %>%
summarise(count = n())
library(data.table)
library(dplyr)
library(haven)
library(stringr)
library(mvtnorm)
library(tidyr)
library(readxl)
library(ggplot2)
library(fuzzyjoin)
library(stringdist)
library(zoo)
library(readxl)
options(scipen = 999)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
# Define the base figure path
figure_path <- "/Users/zrsong/Dropbox (MIT)/Apps/Overleaf/Information Covenants of Direct Lending/Figures"
##################################################
# Section 0: Clean combined_loancontracts and df_merged_crsp
##################################################
#df_merged_crsp <- fread("../Data/LoansFull/df_merged_crsp.csv")
# check if accession if unique by accession and type_attachment
#df_merged_clean <- df_merged_crsp %>%
#  group_by(accession, type_filing, type_attachment) %>%
#  filter(n() == 1)
#combined_loancontracts <- fread("../Data/LoansFull/combined_loancontracts.csv")
# check if obs is unique by accession and type_attachment
#combined_loancontracts_clean <- combined_loancontracts %>%
#  group_by(accession, type_filing, type_attachment) %>%
#  filter(n() == 1)
#cleaned_loancontracts <- inner_join(combined_loancontracts_clean, df_merged_clean, by = c("accession", "type_filing", "type_attachment"))
# save as csv
#write.csv(cleaned_loancontracts, "../Data/LoansFull/cleaned_loancontracts.csv", row.names = FALSE)
### inner join agreements_mm with combined_loancontracts to get text so that I can use to extract deal information
#cleaned_loancontracts <- fread("../Data/LoansFull/cleaned_loancontracts.csv")
# check if contracts have amendments (include words such as 'amendment', 'amended', 'amends', 'restatement', 'restated', 'restates') in the first 1000 characters
#cleaned_loancontracts <- cleaned_loancontracts %>%
#  mutate(is_amendment = ifelse(str_detect(str_sub(text, 1, 1000), "amendment|amended|amends|restatement|restated|restates"), 1, 0))
#cleaned_loancontracts_mm <- cleaned_loancontracts %>%
#  inner_join(agreements_mm %>% select(accession, type_filing, type_attachment), by = c("accession", "type_filing", "type_attachment"))
# keep only non-amendment contracts
#cleaned_loancontracts_mm <- cleaned_loancontracts_mm %>%
#  filter(is_amendment == 0)
# save as csv
#write.csv(cleaned_loancontracts_mm, "../Data/LoansFull/combined_loancontracts_mm.csv", row.names = FALSE)
# read in cleaned_loancontracts_mm
#cleaned_loancontracts_mm <- fread("../Data/LoansFull/combined_loancontracts_mm.csv")
# check for unique years and number of observations by year
# Count number of observations by year
#cleaned_loancontracts_mm <- cleaned_loancontracts_mm %>%
#  group_by(year) %>%
#  summarise(count = n())
##################################################
# Section 0.1: Clean Preqin Fund Names a
##################################################
pattern <- "\\s*(\\b(?:llc|lp|ag|limited|plc|iv|co|gp|spv|inc)\\b)$"
preqin <- read_excel("../Data/Raw/Preqin_deals_export-10-23-2024-1857.xlsx")
names(preqin) <- tolower(names(preqin))
# keep only the needed columns
preqin_names <- preqin[, c("portfolio company", "portfolio company city", "portfolio company state/ county", "debt provider id",
"debt provider name", "debt provider city", "debt provider state/ county", "industry classification")]
# rename the above columns
colnames(preqin_names) <- c("company_name", "company_city", "company_state", "lender_id", "lender_name", "lender_city", "lender_state", "industry")
# change lender_name to lower case
preqin_names <- preqin_names %>%
mutate(lender_name = tolower(lender_name))
# Clean lender_names using the pattern above as well
preqin_names <- preqin_names %>%
mutate(lender_name_cleaned = str_replace_all(lender_name, "\\.", "")) %>%
mutate(lender_name_cleaned = str_trim(str_remove_all(lender_name_cleaned, pattern), side = "both"))
# generate most common industry within each lender_name
preqin_names <- preqin_names %>%
group_by(lender_name_cleaned) %>%
summarise(industry = names(which.max(table(industry))))
# check unique industries
preqin_names %>%
summarise(n_distinct(industry))
# generate lender_names as all lender_name in preqin_names
lender_names <- preqin_names %>%
select(lender_name_cleaned) %>%
distinct()
# generate lender_names as all lender_name in preqin_names
lender_names <- preqin_names %>%
select(lender_name_cleaned) %>%
distinct()
library(data.table)
library(dplyr)
library(haven)
library(stringr)
library(mvtnorm)
library(tidyr)
library(readxl)
library(ggplot2)
library(fuzzyjoin)
library(stringdist)
library(zoo)
library(readxl)
options(scipen = 999)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
# Define the base figure path
figure_path <- "/Users/zrsong/Dropbox (MIT)/Apps/Overleaf/Information Covenants of Direct Lending/Figures"
##################################################
# Section 0: Clean combined_loancontracts and df_merged_crsp
##################################################
#df_merged_crsp <- fread("../Data/LoansFull/df_merged_crsp.csv")
# check if accession if unique by accession and type_attachment
#df_merged_clean <- df_merged_crsp %>%
#  group_by(accession, type_filing, type_attachment) %>%
#  filter(n() == 1)
#combined_loancontracts <- fread("../Data/LoansFull/combined_loancontracts.csv")
# check if obs is unique by accession and type_attachment
#combined_loancontracts_clean <- combined_loancontracts %>%
#  group_by(accession, type_filing, type_attachment) %>%
#  filter(n() == 1)
#cleaned_loancontracts <- inner_join(combined_loancontracts_clean, df_merged_clean, by = c("accession", "type_filing", "type_attachment"))
# save as csv
#write.csv(cleaned_loancontracts, "../Data/LoansFull/cleaned_loancontracts.csv", row.names = FALSE)
### inner join agreements_mm with combined_loancontracts to get text so that I can use to extract deal information
#cleaned_loancontracts <- fread("../Data/LoansFull/cleaned_loancontracts.csv")
# check if contracts have amendments (include words such as 'amendment', 'amended', 'amends', 'restatement', 'restated', 'restates') in the first 1000 characters
#cleaned_loancontracts <- cleaned_loancontracts %>%
#  mutate(is_amendment = ifelse(str_detect(str_sub(text, 1, 1000), "amendment|amended|amends|restatement|restated|restates"), 1, 0))
#cleaned_loancontracts_mm <- cleaned_loancontracts %>%
#  inner_join(agreements_mm %>% select(accession, type_filing, type_attachment), by = c("accession", "type_filing", "type_attachment"))
# keep only non-amendment contracts
#cleaned_loancontracts_mm <- cleaned_loancontracts_mm %>%
#  filter(is_amendment == 0)
# save as csv
#write.csv(cleaned_loancontracts_mm, "../Data/LoansFull/combined_loancontracts_mm.csv", row.names = FALSE)
# read in cleaned_loancontracts_mm
#cleaned_loancontracts_mm <- fread("../Data/LoansFull/combined_loancontracts_mm.csv")
# check for unique years and number of observations by year
# Count number of observations by year
#cleaned_loancontracts_mm <- cleaned_loancontracts_mm %>%
#  group_by(year) %>%
#  summarise(count = n())
##################################################
# Section 0.1: Clean Preqin Fund Names a
##################################################
pattern <- "\\s*(\\b(?:llc|lp|ag|limited|plc|iv|co|gp|spv|inc)\\b)$"
preqin <- read_excel("../Data/Raw/Preqin_deals_export-10-23-2024-1857.xlsx")
names(preqin) <- tolower(names(preqin))
# keep only the needed columns
preqin_names <- preqin[, c("portfolio company", "portfolio company city", "portfolio company state/ county", "debt provider id",
"debt provider name", "debt provider city", "debt provider state/ county", "industry classification")]
# rename the above columns
colnames(preqin_names) <- c("company_name", "company_city", "company_state", "lender_id", "lender_name", "lender_city", "lender_state", "industry")
# change lender_name to lower case
preqin_names <- preqin_names %>%
mutate(lender_name = tolower(lender_name))
# Clean lender_names using the pattern above as well
preqin_names <- preqin_names %>%
mutate(lender_name_cleaned = str_replace_all(lender_name, "\\.", "")) %>%
mutate(lender_name_cleaned = str_trim(str_remove_all(lender_name_cleaned, pattern), side = "both"))
# generate most common industry within each lender_name
preqin_names <- preqin_names %>%
group_by(lender_name_cleaned) %>%
summarise(industry = names(which.max(table(industry))))
# check unique industries
preqin_names %>%
summarise(n_distinct(industry))
# generate lender_names as all lender_name in preqin_names
lender_names <- preqin_names %>%
select(lender_name_cleaned) %>%
distinct()
library(data.table)
library(dplyr)
library(haven)
library(stringr)
library(mvtnorm)
library(tidyr)
library(readxl)
library(ggplot2)
library(fuzzyjoin)
library(stringdist)
library(zoo)
library(readxl)
options(scipen = 999)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls())
# Define the base figure path
figure_path <- "/Users/zrsong/Dropbox (MIT)/Apps/Overleaf/Information Covenants of Direct Lending/Figures"
##################################################
# Section 0: Clean combined_loancontracts and df_merged_crsp
##################################################
#df_merged_crsp <- fread("../Data/LoansFull/df_merged_crsp.csv")
# check if accession if unique by accession and type_attachment
#df_merged_clean <- df_merged_crsp %>%
#  group_by(accession, type_filing, type_attachment) %>%
#  filter(n() == 1)
#combined_loancontracts <- fread("../Data/LoansFull/combined_loancontracts.csv")
# check if obs is unique by accession and type_attachment
#combined_loancontracts_clean <- combined_loancontracts %>%
#  group_by(accession, type_filing, type_attachment) %>%
#  filter(n() == 1)
#cleaned_loancontracts <- inner_join(combined_loancontracts_clean, df_merged_clean, by = c("accession", "type_filing", "type_attachment"))
# save as csv
#write.csv(cleaned_loancontracts, "../Data/LoansFull/cleaned_loancontracts.csv", row.names = FALSE)
### inner join agreements_mm with combined_loancontracts to get text so that I can use to extract deal information
#cleaned_loancontracts <- fread("../Data/LoansFull/cleaned_loancontracts.csv")
# check if contracts have amendments (include words such as 'amendment', 'amended', 'amends', 'restatement', 'restated', 'restates') in the first 1000 characters
#cleaned_loancontracts <- cleaned_loancontracts %>%
#  mutate(is_amendment = ifelse(str_detect(str_sub(text, 1, 1000), "amendment|amended|amends|restatement|restated|restates"), 1, 0))
#cleaned_loancontracts_mm <- cleaned_loancontracts %>%
#  inner_join(agreements_mm %>% select(accession, type_filing, type_attachment), by = c("accession", "type_filing", "type_attachment"))
# keep only non-amendment contracts
#cleaned_loancontracts_mm <- cleaned_loancontracts_mm %>%
#  filter(is_amendment == 0)
# save as csv
#write.csv(cleaned_loancontracts_mm, "../Data/LoansFull/combined_loancontracts_mm.csv", row.names = FALSE)
# read in cleaned_loancontracts_mm
#cleaned_loancontracts_mm <- fread("../Data/LoansFull/combined_loancontracts_mm.csv")
# check for unique years and number of observations by year
# Count number of observations by year
#cleaned_loancontracts_mm <- cleaned_loancontracts_mm %>%
#  group_by(year) %>%
#  summarise(count = n())
##################################################
# Section 0.1: Clean Preqin Fund Names a
##################################################
pattern <- "\\s*(\\b(?:llc|lp|ag|limited|plc|iv|co|gp|spv|inc)\\b)$"
preqin <- read_excel("../Data/Raw/Preqin_deals_export-10-23-2024-1857.xlsx")
names(preqin) <- tolower(names(preqin))
# keep only the needed columns
preqin_names <- preqin[, c("portfolio company", "portfolio company city", "portfolio company state/ county", "debt provider id",
"debt provider name", "debt provider city", "debt provider state/ county", "industry classification")]
# rename the above columns
colnames(preqin_names) <- c("company_name", "company_city", "company_state", "lender_id", "lender_name", "lender_city", "lender_state", "industry")
# change lender_name to lower case
preqin_names <- preqin_names %>%
mutate(lender_name = tolower(lender_name))
# Clean lender_names using the pattern above as well
preqin_names <- preqin_names %>%
mutate(lender_name_cleaned = str_replace_all(lender_name, "\\.", "")) %>%
mutate(lender_name_cleaned = str_trim(str_remove_all(lender_name_cleaned, pattern), side = "both"))
# generate most common industry within each lender_name
preqin_names <- preqin_names %>%
group_by(lender_name_cleaned) %>%
summarise(industry = names(which.max(table(industry))))
# check unique industries
preqin_names %>%
summarise(n_distinct(industry))
# generate lender_names as all lender_name in preqin_names
lender_names <- preqin_names %>%
select(lender_name_cleaned) %>%
distinct()
lender_names <- preqin_names %>%
select(lender_name_cleaned) %>%
distinct()
colnames(preqin_names)
lender_names <- preqin_names %>%
select(lender_name_cleaned) %>%
distinct()
lender_names <- preqin_names %>%
select(lender_name_cleaned)
pattern <- "\\s*(\\b(?:llc|lp|ag|limited|plc|iv|co|gp|spv|inc)\\b)$"
preqin <- read_excel("../Data/Raw/Preqin_deals_export-10-23-2024-1857.xlsx")
names(preqin) <- tolower(names(preqin))
# keep only the needed columns
preqin_names <- preqin[, c("portfolio company", "portfolio company city", "portfolio company state/ county", "debt provider id",
"debt provider name", "debt provider city", "debt provider state/ county", "industry classification")]
# rename the above columns
colnames(preqin_names) <- c("company_name", "company_city", "company_state", "lender_id", "lender_name", "lender_city", "lender_state", "industry")
# change lender_name to lower case
preqin_names <- preqin_names %>%
mutate(lender_name = tolower(lender_name))
# Clean lender_names using the pattern above as well
preqin_names <- preqin_names %>%
mutate(lender_name_cleaned = str_replace_all(lender_name, "\\.", "")) %>%
mutate(lender_name_cleaned = str_trim(str_remove_all(lender_name_cleaned, pattern), side = "both"))
# generate most common industry within each lender_name
preqin_names <- preqin_names %>%
group_by(lender_name_cleaned) %>%
summarise(industry = names(which.max(table(industry))))
# check unique industries
preqin_names %>%
summarise(n_distinct(industry))
lender_names <- preqin_names %>%
select(lender_name_cleaned) %>%
distinct()
